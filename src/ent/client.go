// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/0B1t322/CP-Rosseti-Back/ent/migrate"

	"github.com/0B1t322/CP-Rosseti-Back/ent/answer"
	"github.com/0B1t322/CP-Rosseti-Back/ent/module"
	"github.com/0B1t322/CP-Rosseti-Back/ent/moduledependcies"
	"github.com/0B1t322/CP-Rosseti-Back/ent/moduletest"
	"github.com/0B1t322/CP-Rosseti-Back/ent/practtest"
	"github.com/0B1t322/CP-Rosseti-Back/ent/question"
	"github.com/0B1t322/CP-Rosseti-Back/ent/role"
	"github.com/0B1t322/CP-Rosseti-Back/ent/submodule"
	"github.com/0B1t322/CP-Rosseti-Back/ent/submoduletest"
	"github.com/0B1t322/CP-Rosseti-Back/ent/test"
	"github.com/0B1t322/CP-Rosseti-Back/ent/theoreticaltest"
	"github.com/0B1t322/CP-Rosseti-Back/ent/user"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Answer is the client for interacting with the Answer builders.
	Answer *AnswerClient
	// Module is the client for interacting with the Module builders.
	Module *ModuleClient
	// ModuleDependcies is the client for interacting with the ModuleDependcies builders.
	ModuleDependcies *ModuleDependciesClient
	// ModuleTest is the client for interacting with the ModuleTest builders.
	ModuleTest *ModuleTestClient
	// PractTest is the client for interacting with the PractTest builders.
	PractTest *PractTestClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// SubModule is the client for interacting with the SubModule builders.
	SubModule *SubModuleClient
	// SubModuleTest is the client for interacting with the SubModuleTest builders.
	SubModuleTest *SubModuleTestClient
	// Test is the client for interacting with the Test builders.
	Test *TestClient
	// TheoreticalTest is the client for interacting with the TheoreticalTest builders.
	TheoreticalTest *TheoreticalTestClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Answer = NewAnswerClient(c.config)
	c.Module = NewModuleClient(c.config)
	c.ModuleDependcies = NewModuleDependciesClient(c.config)
	c.ModuleTest = NewModuleTestClient(c.config)
	c.PractTest = NewPractTestClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.SubModule = NewSubModuleClient(c.config)
	c.SubModuleTest = NewSubModuleTestClient(c.config)
	c.Test = NewTestClient(c.config)
	c.TheoreticalTest = NewTheoreticalTestClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Answer:           NewAnswerClient(cfg),
		Module:           NewModuleClient(cfg),
		ModuleDependcies: NewModuleDependciesClient(cfg),
		ModuleTest:       NewModuleTestClient(cfg),
		PractTest:        NewPractTestClient(cfg),
		Question:         NewQuestionClient(cfg),
		Role:             NewRoleClient(cfg),
		SubModule:        NewSubModuleClient(cfg),
		SubModuleTest:    NewSubModuleTestClient(cfg),
		Test:             NewTestClient(cfg),
		TheoreticalTest:  NewTheoreticalTestClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		config:           cfg,
		Answer:           NewAnswerClient(cfg),
		Module:           NewModuleClient(cfg),
		ModuleDependcies: NewModuleDependciesClient(cfg),
		ModuleTest:       NewModuleTestClient(cfg),
		PractTest:        NewPractTestClient(cfg),
		Question:         NewQuestionClient(cfg),
		Role:             NewRoleClient(cfg),
		SubModule:        NewSubModuleClient(cfg),
		SubModuleTest:    NewSubModuleTestClient(cfg),
		Test:             NewTestClient(cfg),
		TheoreticalTest:  NewTheoreticalTestClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Answer.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Answer.Use(hooks...)
	c.Module.Use(hooks...)
	c.ModuleDependcies.Use(hooks...)
	c.ModuleTest.Use(hooks...)
	c.PractTest.Use(hooks...)
	c.Question.Use(hooks...)
	c.Role.Use(hooks...)
	c.SubModule.Use(hooks...)
	c.SubModuleTest.Use(hooks...)
	c.Test.Use(hooks...)
	c.TheoreticalTest.Use(hooks...)
	c.User.Use(hooks...)
}

// AnswerClient is a client for the Answer schema.
type AnswerClient struct {
	config
}

// NewAnswerClient returns a client for the Answer from the given config.
func NewAnswerClient(c config) *AnswerClient {
	return &AnswerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `answer.Hooks(f(g(h())))`.
func (c *AnswerClient) Use(hooks ...Hook) {
	c.hooks.Answer = append(c.hooks.Answer, hooks...)
}

// Create returns a create builder for Answer.
func (c *AnswerClient) Create() *AnswerCreate {
	mutation := newAnswerMutation(c.config, OpCreate)
	return &AnswerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Answer entities.
func (c *AnswerClient) CreateBulk(builders ...*AnswerCreate) *AnswerCreateBulk {
	return &AnswerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Answer.
func (c *AnswerClient) Update() *AnswerUpdate {
	mutation := newAnswerMutation(c.config, OpUpdate)
	return &AnswerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnswerClient) UpdateOne(a *Answer) *AnswerUpdateOne {
	mutation := newAnswerMutation(c.config, OpUpdateOne, withAnswer(a))
	return &AnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnswerClient) UpdateOneID(id int) *AnswerUpdateOne {
	mutation := newAnswerMutation(c.config, OpUpdateOne, withAnswerID(id))
	return &AnswerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Answer.
func (c *AnswerClient) Delete() *AnswerDelete {
	mutation := newAnswerMutation(c.config, OpDelete)
	return &AnswerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AnswerClient) DeleteOne(a *Answer) *AnswerDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AnswerClient) DeleteOneID(id int) *AnswerDeleteOne {
	builder := c.Delete().Where(answer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnswerDeleteOne{builder}
}

// Query returns a query builder for Answer.
func (c *AnswerClient) Query() *AnswerQuery {
	return &AnswerQuery{
		config: c.config,
	}
}

// Get returns a Answer entity by its id.
func (c *AnswerClient) Get(ctx context.Context, id int) (*Answer, error) {
	return c.Query().Where(answer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnswerClient) GetX(ctx context.Context, id int) *Answer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestuion queries the Questuion edge of a Answer.
func (c *AnswerClient) QueryQuestuion(a *Answer) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(answer.Table, answer.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, answer.QuestuionTable, answer.QuestuionColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnswerClient) Hooks() []Hook {
	return c.hooks.Answer
}

// ModuleClient is a client for the Module schema.
type ModuleClient struct {
	config
}

// NewModuleClient returns a client for the Module from the given config.
func NewModuleClient(c config) *ModuleClient {
	return &ModuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `module.Hooks(f(g(h())))`.
func (c *ModuleClient) Use(hooks ...Hook) {
	c.hooks.Module = append(c.hooks.Module, hooks...)
}

// Create returns a create builder for Module.
func (c *ModuleClient) Create() *ModuleCreate {
	mutation := newModuleMutation(c.config, OpCreate)
	return &ModuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Module entities.
func (c *ModuleClient) CreateBulk(builders ...*ModuleCreate) *ModuleCreateBulk {
	return &ModuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Module.
func (c *ModuleClient) Update() *ModuleUpdate {
	mutation := newModuleMutation(c.config, OpUpdate)
	return &ModuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ModuleClient) UpdateOne(m *Module) *ModuleUpdateOne {
	mutation := newModuleMutation(c.config, OpUpdateOne, withModule(m))
	return &ModuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ModuleClient) UpdateOneID(id int) *ModuleUpdateOne {
	mutation := newModuleMutation(c.config, OpUpdateOne, withModuleID(id))
	return &ModuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Module.
func (c *ModuleClient) Delete() *ModuleDelete {
	mutation := newModuleMutation(c.config, OpDelete)
	return &ModuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ModuleClient) DeleteOne(m *Module) *ModuleDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ModuleClient) DeleteOneID(id int) *ModuleDeleteOne {
	builder := c.Delete().Where(module.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ModuleDeleteOne{builder}
}

// Query returns a query builder for Module.
func (c *ModuleClient) Query() *ModuleQuery {
	return &ModuleQuery{
		config: c.config,
	}
}

// Get returns a Module entity by its id.
func (c *ModuleClient) Get(ctx context.Context, id int) (*Module, error) {
	return c.Query().Where(module.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ModuleClient) GetX(ctx context.Context, id int) *Module {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryModuleDependcies queries the ModuleDependcies edge of a Module.
func (c *ModuleClient) QueryModuleDependcies(m *Module) *ModuleDependciesQuery {
	query := &ModuleDependciesQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(module.Table, module.FieldID, id),
			sqlgraph.To(moduledependcies.Table, moduledependcies.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, module.ModuleDependciesTable, module.ModuleDependciesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryModuleDependOn queries the ModuleDependOn edge of a Module.
func (c *ModuleClient) QueryModuleDependOn(m *Module) *ModuleDependciesQuery {
	query := &ModuleDependciesQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(module.Table, module.FieldID, id),
			sqlgraph.To(moduledependcies.Table, moduledependcies.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, module.ModuleDependOnTable, module.ModuleDependOnColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubModules queries the SubModules edge of a Module.
func (c *ModuleClient) QuerySubModules(m *Module) *SubModuleQuery {
	query := &SubModuleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(module.Table, module.FieldID, id),
			sqlgraph.To(submodule.Table, submodule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, module.SubModulesTable, module.SubModulesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTest queries the Test edge of a Module.
func (c *ModuleClient) QueryTest(m *Module) *ModuleTestQuery {
	query := &ModuleTestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(module.Table, module.FieldID, id),
			sqlgraph.To(moduletest.Table, moduletest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, module.TestTable, module.TestColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ModuleClient) Hooks() []Hook {
	return c.hooks.Module
}

// ModuleDependciesClient is a client for the ModuleDependcies schema.
type ModuleDependciesClient struct {
	config
}

// NewModuleDependciesClient returns a client for the ModuleDependcies from the given config.
func NewModuleDependciesClient(c config) *ModuleDependciesClient {
	return &ModuleDependciesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `moduledependcies.Hooks(f(g(h())))`.
func (c *ModuleDependciesClient) Use(hooks ...Hook) {
	c.hooks.ModuleDependcies = append(c.hooks.ModuleDependcies, hooks...)
}

// Create returns a create builder for ModuleDependcies.
func (c *ModuleDependciesClient) Create() *ModuleDependciesCreate {
	mutation := newModuleDependciesMutation(c.config, OpCreate)
	return &ModuleDependciesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ModuleDependcies entities.
func (c *ModuleDependciesClient) CreateBulk(builders ...*ModuleDependciesCreate) *ModuleDependciesCreateBulk {
	return &ModuleDependciesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ModuleDependcies.
func (c *ModuleDependciesClient) Update() *ModuleDependciesUpdate {
	mutation := newModuleDependciesMutation(c.config, OpUpdate)
	return &ModuleDependciesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ModuleDependciesClient) UpdateOne(md *ModuleDependcies) *ModuleDependciesUpdateOne {
	mutation := newModuleDependciesMutation(c.config, OpUpdateOne, withModuleDependcies(md))
	return &ModuleDependciesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ModuleDependciesClient) UpdateOneID(id int) *ModuleDependciesUpdateOne {
	mutation := newModuleDependciesMutation(c.config, OpUpdateOne, withModuleDependciesID(id))
	return &ModuleDependciesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ModuleDependcies.
func (c *ModuleDependciesClient) Delete() *ModuleDependciesDelete {
	mutation := newModuleDependciesMutation(c.config, OpDelete)
	return &ModuleDependciesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ModuleDependciesClient) DeleteOne(md *ModuleDependcies) *ModuleDependciesDeleteOne {
	return c.DeleteOneID(md.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ModuleDependciesClient) DeleteOneID(id int) *ModuleDependciesDeleteOne {
	builder := c.Delete().Where(moduledependcies.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ModuleDependciesDeleteOne{builder}
}

// Query returns a query builder for ModuleDependcies.
func (c *ModuleDependciesClient) Query() *ModuleDependciesQuery {
	return &ModuleDependciesQuery{
		config: c.config,
	}
}

// Get returns a ModuleDependcies entity by its id.
func (c *ModuleDependciesClient) Get(ctx context.Context, id int) (*ModuleDependcies, error) {
	return c.Query().Where(moduledependcies.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ModuleDependciesClient) GetX(ctx context.Context, id int) *ModuleDependcies {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryModuleDependcies queries the ModuleDependcies edge of a ModuleDependcies.
func (c *ModuleDependciesClient) QueryModuleDependcies(md *ModuleDependcies) *ModuleQuery {
	query := &ModuleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := md.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(moduledependcies.Table, moduledependcies.FieldID, id),
			sqlgraph.To(module.Table, module.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, moduledependcies.ModuleDependciesTable, moduledependcies.ModuleDependciesColumn),
		)
		fromV = sqlgraph.Neighbors(md.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryModuleDependOn queries the ModuleDependOn edge of a ModuleDependcies.
func (c *ModuleDependciesClient) QueryModuleDependOn(md *ModuleDependcies) *ModuleQuery {
	query := &ModuleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := md.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(moduledependcies.Table, moduledependcies.FieldID, id),
			sqlgraph.To(module.Table, module.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, moduledependcies.ModuleDependOnTable, moduledependcies.ModuleDependOnColumn),
		)
		fromV = sqlgraph.Neighbors(md.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ModuleDependciesClient) Hooks() []Hook {
	return c.hooks.ModuleDependcies
}

// ModuleTestClient is a client for the ModuleTest schema.
type ModuleTestClient struct {
	config
}

// NewModuleTestClient returns a client for the ModuleTest from the given config.
func NewModuleTestClient(c config) *ModuleTestClient {
	return &ModuleTestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `moduletest.Hooks(f(g(h())))`.
func (c *ModuleTestClient) Use(hooks ...Hook) {
	c.hooks.ModuleTest = append(c.hooks.ModuleTest, hooks...)
}

// Create returns a create builder for ModuleTest.
func (c *ModuleTestClient) Create() *ModuleTestCreate {
	mutation := newModuleTestMutation(c.config, OpCreate)
	return &ModuleTestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ModuleTest entities.
func (c *ModuleTestClient) CreateBulk(builders ...*ModuleTestCreate) *ModuleTestCreateBulk {
	return &ModuleTestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ModuleTest.
func (c *ModuleTestClient) Update() *ModuleTestUpdate {
	mutation := newModuleTestMutation(c.config, OpUpdate)
	return &ModuleTestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ModuleTestClient) UpdateOne(mt *ModuleTest) *ModuleTestUpdateOne {
	mutation := newModuleTestMutation(c.config, OpUpdateOne, withModuleTest(mt))
	return &ModuleTestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ModuleTestClient) UpdateOneID(id int) *ModuleTestUpdateOne {
	mutation := newModuleTestMutation(c.config, OpUpdateOne, withModuleTestID(id))
	return &ModuleTestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ModuleTest.
func (c *ModuleTestClient) Delete() *ModuleTestDelete {
	mutation := newModuleTestMutation(c.config, OpDelete)
	return &ModuleTestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ModuleTestClient) DeleteOne(mt *ModuleTest) *ModuleTestDeleteOne {
	return c.DeleteOneID(mt.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ModuleTestClient) DeleteOneID(id int) *ModuleTestDeleteOne {
	builder := c.Delete().Where(moduletest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ModuleTestDeleteOne{builder}
}

// Query returns a query builder for ModuleTest.
func (c *ModuleTestClient) Query() *ModuleTestQuery {
	return &ModuleTestQuery{
		config: c.config,
	}
}

// Get returns a ModuleTest entity by its id.
func (c *ModuleTestClient) Get(ctx context.Context, id int) (*ModuleTest, error) {
	return c.Query().Where(moduletest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ModuleTestClient) GetX(ctx context.Context, id int) *ModuleTest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryModule queries the Module edge of a ModuleTest.
func (c *ModuleTestClient) QueryModule(mt *ModuleTest) *ModuleQuery {
	query := &ModuleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := mt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(moduletest.Table, moduletest.FieldID, id),
			sqlgraph.To(module.Table, module.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, moduletest.ModuleTable, moduletest.ModuleColumn),
		)
		fromV = sqlgraph.Neighbors(mt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTest queries the Test edge of a ModuleTest.
func (c *ModuleTestClient) QueryTest(mt *ModuleTest) *TestQuery {
	query := &TestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := mt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(moduletest.Table, moduletest.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, moduletest.TestTable, moduletest.TestColumn),
		)
		fromV = sqlgraph.Neighbors(mt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ModuleTestClient) Hooks() []Hook {
	return c.hooks.ModuleTest
}

// PractTestClient is a client for the PractTest schema.
type PractTestClient struct {
	config
}

// NewPractTestClient returns a client for the PractTest from the given config.
func NewPractTestClient(c config) *PractTestClient {
	return &PractTestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `practtest.Hooks(f(g(h())))`.
func (c *PractTestClient) Use(hooks ...Hook) {
	c.hooks.PractTest = append(c.hooks.PractTest, hooks...)
}

// Create returns a create builder for PractTest.
func (c *PractTestClient) Create() *PractTestCreate {
	mutation := newPractTestMutation(c.config, OpCreate)
	return &PractTestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PractTest entities.
func (c *PractTestClient) CreateBulk(builders ...*PractTestCreate) *PractTestCreateBulk {
	return &PractTestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PractTest.
func (c *PractTestClient) Update() *PractTestUpdate {
	mutation := newPractTestMutation(c.config, OpUpdate)
	return &PractTestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PractTestClient) UpdateOne(pt *PractTest) *PractTestUpdateOne {
	mutation := newPractTestMutation(c.config, OpUpdateOne, withPractTest(pt))
	return &PractTestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PractTestClient) UpdateOneID(id int) *PractTestUpdateOne {
	mutation := newPractTestMutation(c.config, OpUpdateOne, withPractTestID(id))
	return &PractTestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PractTest.
func (c *PractTestClient) Delete() *PractTestDelete {
	mutation := newPractTestMutation(c.config, OpDelete)
	return &PractTestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PractTestClient) DeleteOne(pt *PractTest) *PractTestDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PractTestClient) DeleteOneID(id int) *PractTestDeleteOne {
	builder := c.Delete().Where(practtest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PractTestDeleteOne{builder}
}

// Query returns a query builder for PractTest.
func (c *PractTestClient) Query() *PractTestQuery {
	return &PractTestQuery{
		config: c.config,
	}
}

// Get returns a PractTest entity by its id.
func (c *PractTestClient) Get(ctx context.Context, id int) (*PractTest, error) {
	return c.Query().Where(practtest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PractTestClient) GetX(ctx context.Context, id int) *PractTest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTest queries the Test edge of a PractTest.
func (c *PractTestClient) QueryTest(pt *PractTest) *TestQuery {
	query := &TestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(practtest.Table, practtest.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, practtest.TestTable, practtest.TestColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PractTestClient) Hooks() []Hook {
	return c.hooks.PractTest
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Create returns a create builder for Question.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Question entities.
func (c *QuestionClient) CreateBulk(builders ...*QuestionCreate) *QuestionCreateBulk {
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(q *Question) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestion(q))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id int) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestionID(id))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *QuestionClient) DeleteOne(q *Question) *QuestionDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *QuestionClient) DeleteOneID(id int) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Query returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{
		config: c.config,
	}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id int) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id int) *Question {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTheoreticalTest queries the TheoreticalTest edge of a Question.
func (c *QuestionClient) QueryTheoreticalTest(q *Question) *TheoreticalTestQuery {
	query := &TheoreticalTestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(theoreticaltest.Table, theoreticaltest.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.TheoreticalTestTable, question.TheoreticalTestColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnswer queries the Answer edge of a Question.
func (c *QuestionClient) QueryAnswer(q *Question) *AnswerQuery {
	query := &AnswerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(answer.Table, answer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.AnswerTable, question.AnswerColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	return c.hooks.Question
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Create returns a create builder for Role.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id int) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RoleClient) DeleteOneID(id int) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id int) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id int) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the User edge of a Role.
func (c *RoleClient) QueryUser(r *Role) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.UserTable, role.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	return c.hooks.Role
}

// SubModuleClient is a client for the SubModule schema.
type SubModuleClient struct {
	config
}

// NewSubModuleClient returns a client for the SubModule from the given config.
func NewSubModuleClient(c config) *SubModuleClient {
	return &SubModuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `submodule.Hooks(f(g(h())))`.
func (c *SubModuleClient) Use(hooks ...Hook) {
	c.hooks.SubModule = append(c.hooks.SubModule, hooks...)
}

// Create returns a create builder for SubModule.
func (c *SubModuleClient) Create() *SubModuleCreate {
	mutation := newSubModuleMutation(c.config, OpCreate)
	return &SubModuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubModule entities.
func (c *SubModuleClient) CreateBulk(builders ...*SubModuleCreate) *SubModuleCreateBulk {
	return &SubModuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubModule.
func (c *SubModuleClient) Update() *SubModuleUpdate {
	mutation := newSubModuleMutation(c.config, OpUpdate)
	return &SubModuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubModuleClient) UpdateOne(sm *SubModule) *SubModuleUpdateOne {
	mutation := newSubModuleMutation(c.config, OpUpdateOne, withSubModule(sm))
	return &SubModuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubModuleClient) UpdateOneID(id int) *SubModuleUpdateOne {
	mutation := newSubModuleMutation(c.config, OpUpdateOne, withSubModuleID(id))
	return &SubModuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubModule.
func (c *SubModuleClient) Delete() *SubModuleDelete {
	mutation := newSubModuleMutation(c.config, OpDelete)
	return &SubModuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SubModuleClient) DeleteOne(sm *SubModule) *SubModuleDeleteOne {
	return c.DeleteOneID(sm.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SubModuleClient) DeleteOneID(id int) *SubModuleDeleteOne {
	builder := c.Delete().Where(submodule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubModuleDeleteOne{builder}
}

// Query returns a query builder for SubModule.
func (c *SubModuleClient) Query() *SubModuleQuery {
	return &SubModuleQuery{
		config: c.config,
	}
}

// Get returns a SubModule entity by its id.
func (c *SubModuleClient) Get(ctx context.Context, id int) (*SubModule, error) {
	return c.Query().Where(submodule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubModuleClient) GetX(ctx context.Context, id int) *SubModule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryModule queries the Module edge of a SubModule.
func (c *SubModuleClient) QueryModule(sm *SubModule) *ModuleQuery {
	query := &ModuleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := sm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(submodule.Table, submodule.FieldID, id),
			sqlgraph.To(module.Table, module.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, submodule.ModuleTable, submodule.ModuleColumn),
		)
		fromV = sqlgraph.Neighbors(sm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTest queries the Test edge of a SubModule.
func (c *SubModuleClient) QueryTest(sm *SubModule) *SubModuleTestQuery {
	query := &SubModuleTestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := sm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(submodule.Table, submodule.FieldID, id),
			sqlgraph.To(submoduletest.Table, submoduletest.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, submodule.TestTable, submodule.TestColumn),
		)
		fromV = sqlgraph.Neighbors(sm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubModuleClient) Hooks() []Hook {
	return c.hooks.SubModule
}

// SubModuleTestClient is a client for the SubModuleTest schema.
type SubModuleTestClient struct {
	config
}

// NewSubModuleTestClient returns a client for the SubModuleTest from the given config.
func NewSubModuleTestClient(c config) *SubModuleTestClient {
	return &SubModuleTestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `submoduletest.Hooks(f(g(h())))`.
func (c *SubModuleTestClient) Use(hooks ...Hook) {
	c.hooks.SubModuleTest = append(c.hooks.SubModuleTest, hooks...)
}

// Create returns a create builder for SubModuleTest.
func (c *SubModuleTestClient) Create() *SubModuleTestCreate {
	mutation := newSubModuleTestMutation(c.config, OpCreate)
	return &SubModuleTestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubModuleTest entities.
func (c *SubModuleTestClient) CreateBulk(builders ...*SubModuleTestCreate) *SubModuleTestCreateBulk {
	return &SubModuleTestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubModuleTest.
func (c *SubModuleTestClient) Update() *SubModuleTestUpdate {
	mutation := newSubModuleTestMutation(c.config, OpUpdate)
	return &SubModuleTestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubModuleTestClient) UpdateOne(smt *SubModuleTest) *SubModuleTestUpdateOne {
	mutation := newSubModuleTestMutation(c.config, OpUpdateOne, withSubModuleTest(smt))
	return &SubModuleTestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubModuleTestClient) UpdateOneID(id int) *SubModuleTestUpdateOne {
	mutation := newSubModuleTestMutation(c.config, OpUpdateOne, withSubModuleTestID(id))
	return &SubModuleTestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubModuleTest.
func (c *SubModuleTestClient) Delete() *SubModuleTestDelete {
	mutation := newSubModuleTestMutation(c.config, OpDelete)
	return &SubModuleTestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SubModuleTestClient) DeleteOne(smt *SubModuleTest) *SubModuleTestDeleteOne {
	return c.DeleteOneID(smt.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SubModuleTestClient) DeleteOneID(id int) *SubModuleTestDeleteOne {
	builder := c.Delete().Where(submoduletest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubModuleTestDeleteOne{builder}
}

// Query returns a query builder for SubModuleTest.
func (c *SubModuleTestClient) Query() *SubModuleTestQuery {
	return &SubModuleTestQuery{
		config: c.config,
	}
}

// Get returns a SubModuleTest entity by its id.
func (c *SubModuleTestClient) Get(ctx context.Context, id int) (*SubModuleTest, error) {
	return c.Query().Where(submoduletest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubModuleTestClient) GetX(ctx context.Context, id int) *SubModuleTest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubModule queries the SubModule edge of a SubModuleTest.
func (c *SubModuleTestClient) QuerySubModule(smt *SubModuleTest) *SubModuleQuery {
	query := &SubModuleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := smt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(submoduletest.Table, submoduletest.FieldID, id),
			sqlgraph.To(submodule.Table, submodule.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, submoduletest.SubModuleTable, submoduletest.SubModuleColumn),
		)
		fromV = sqlgraph.Neighbors(smt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTest queries the Test edge of a SubModuleTest.
func (c *SubModuleTestClient) QueryTest(smt *SubModuleTest) *TestQuery {
	query := &TestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := smt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(submoduletest.Table, submoduletest.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, submoduletest.TestTable, submoduletest.TestColumn),
		)
		fromV = sqlgraph.Neighbors(smt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubModuleTestClient) Hooks() []Hook {
	return c.hooks.SubModuleTest
}

// TestClient is a client for the Test schema.
type TestClient struct {
	config
}

// NewTestClient returns a client for the Test from the given config.
func NewTestClient(c config) *TestClient {
	return &TestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `test.Hooks(f(g(h())))`.
func (c *TestClient) Use(hooks ...Hook) {
	c.hooks.Test = append(c.hooks.Test, hooks...)
}

// Create returns a create builder for Test.
func (c *TestClient) Create() *TestCreate {
	mutation := newTestMutation(c.config, OpCreate)
	return &TestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Test entities.
func (c *TestClient) CreateBulk(builders ...*TestCreate) *TestCreateBulk {
	return &TestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Test.
func (c *TestClient) Update() *TestUpdate {
	mutation := newTestMutation(c.config, OpUpdate)
	return &TestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestClient) UpdateOne(t *Test) *TestUpdateOne {
	mutation := newTestMutation(c.config, OpUpdateOne, withTest(t))
	return &TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestClient) UpdateOneID(id int) *TestUpdateOne {
	mutation := newTestMutation(c.config, OpUpdateOne, withTestID(id))
	return &TestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Test.
func (c *TestClient) Delete() *TestDelete {
	mutation := newTestMutation(c.config, OpDelete)
	return &TestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TestClient) DeleteOne(t *Test) *TestDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TestClient) DeleteOneID(id int) *TestDeleteOne {
	builder := c.Delete().Where(test.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestDeleteOne{builder}
}

// Query returns a query builder for Test.
func (c *TestClient) Query() *TestQuery {
	return &TestQuery{
		config: c.config,
	}
}

// Get returns a Test entity by its id.
func (c *TestClient) Get(ctx context.Context, id int) (*Test, error) {
	return c.Query().Where(test.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestClient) GetX(ctx context.Context, id int) *Test {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryModuleTest queries the ModuleTest edge of a Test.
func (c *TestClient) QueryModuleTest(t *Test) *ModuleTestQuery {
	query := &ModuleTestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(moduletest.Table, moduletest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, test.ModuleTestTable, test.ModuleTestColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubmoduleTest queries the SubmoduleTest edge of a Test.
func (c *TestClient) QuerySubmoduleTest(t *Test) *SubModuleTestQuery {
	query := &SubModuleTestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(submoduletest.Table, submoduletest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, test.SubmoduleTestTable, test.SubmoduleTestColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTherTest queries the TherTest edge of a Test.
func (c *TestClient) QueryTherTest(t *Test) *TheoreticalTestQuery {
	query := &TheoreticalTestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(theoreticaltest.Table, theoreticaltest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, test.TherTestTable, test.TherTestColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPractTest queries the PractTest edge of a Test.
func (c *TestClient) QueryPractTest(t *Test) *PractTestQuery {
	query := &PractTestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(test.Table, test.FieldID, id),
			sqlgraph.To(practtest.Table, practtest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, test.PractTestTable, test.PractTestColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestClient) Hooks() []Hook {
	return c.hooks.Test
}

// TheoreticalTestClient is a client for the TheoreticalTest schema.
type TheoreticalTestClient struct {
	config
}

// NewTheoreticalTestClient returns a client for the TheoreticalTest from the given config.
func NewTheoreticalTestClient(c config) *TheoreticalTestClient {
	return &TheoreticalTestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `theoreticaltest.Hooks(f(g(h())))`.
func (c *TheoreticalTestClient) Use(hooks ...Hook) {
	c.hooks.TheoreticalTest = append(c.hooks.TheoreticalTest, hooks...)
}

// Create returns a create builder for TheoreticalTest.
func (c *TheoreticalTestClient) Create() *TheoreticalTestCreate {
	mutation := newTheoreticalTestMutation(c.config, OpCreate)
	return &TheoreticalTestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TheoreticalTest entities.
func (c *TheoreticalTestClient) CreateBulk(builders ...*TheoreticalTestCreate) *TheoreticalTestCreateBulk {
	return &TheoreticalTestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TheoreticalTest.
func (c *TheoreticalTestClient) Update() *TheoreticalTestUpdate {
	mutation := newTheoreticalTestMutation(c.config, OpUpdate)
	return &TheoreticalTestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TheoreticalTestClient) UpdateOne(tt *TheoreticalTest) *TheoreticalTestUpdateOne {
	mutation := newTheoreticalTestMutation(c.config, OpUpdateOne, withTheoreticalTest(tt))
	return &TheoreticalTestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TheoreticalTestClient) UpdateOneID(id int) *TheoreticalTestUpdateOne {
	mutation := newTheoreticalTestMutation(c.config, OpUpdateOne, withTheoreticalTestID(id))
	return &TheoreticalTestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TheoreticalTest.
func (c *TheoreticalTestClient) Delete() *TheoreticalTestDelete {
	mutation := newTheoreticalTestMutation(c.config, OpDelete)
	return &TheoreticalTestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TheoreticalTestClient) DeleteOne(tt *TheoreticalTest) *TheoreticalTestDeleteOne {
	return c.DeleteOneID(tt.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TheoreticalTestClient) DeleteOneID(id int) *TheoreticalTestDeleteOne {
	builder := c.Delete().Where(theoreticaltest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TheoreticalTestDeleteOne{builder}
}

// Query returns a query builder for TheoreticalTest.
func (c *TheoreticalTestClient) Query() *TheoreticalTestQuery {
	return &TheoreticalTestQuery{
		config: c.config,
	}
}

// Get returns a TheoreticalTest entity by its id.
func (c *TheoreticalTestClient) Get(ctx context.Context, id int) (*TheoreticalTest, error) {
	return c.Query().Where(theoreticaltest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TheoreticalTestClient) GetX(ctx context.Context, id int) *TheoreticalTest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTest queries the Test edge of a TheoreticalTest.
func (c *TheoreticalTestClient) QueryTest(tt *TheoreticalTest) *TestQuery {
	query := &TestQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(theoreticaltest.Table, theoreticaltest.FieldID, id),
			sqlgraph.To(test.Table, test.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, theoreticaltest.TestTable, theoreticaltest.TestColumn),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestion queries the Question edge of a TheoreticalTest.
func (c *TheoreticalTestClient) QueryQuestion(tt *TheoreticalTest) *QuestionQuery {
	query := &QuestionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(theoreticaltest.Table, theoreticaltest.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, theoreticaltest.QuestionTable, theoreticaltest.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TheoreticalTestClient) Hooks() []Hook {
	return c.hooks.TheoreticalTest
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRole queries the Role edge of a User.
func (c *UserClient) QueryRole(u *User) *RoleQuery {
	query := &RoleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.RoleTable, user.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
